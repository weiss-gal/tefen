# סיכום שיעור - פעולות ומשתנים

## חומרים לשיעור

- מצגת של הילה קדמן בנושא המרות. עמודים 1 עד 11 ועמודים 22 עד 37

לינק למצגת: [מצגת המרות](https://drive.google.com/file/d/1AZQmVzFuO1SEvWSKUj5luib_OA3Da-Ny/view)

## המרת מעלות צלסיוס לפרנהייט

למדנו כי נוסחת ההמרה ממעלות צלסיוס הנהוגות בישראל למעלות פרנהייט הנהוגות בארה"ב היא:

$$
F = \frac{9}{5}C + 32
$$

במילים, כדי לתרגם מספר מעלות בצלסיוס לפרנהייט ניקח המספר בצלסיוס (C בנוסחא) נכפול אותו ב9/5 ונוסיף 32.

## תרגום בעזרת קוד

ננסה לכתוב מחשבון פשוט שמבצע את ההמרה

```csharp
Console.WriteLine("Please type the temprature in Celsius:");

int celsiusDegrees;
celsiusDegrees = int.Parse(Console.ReadLine());

Console.WriteLine("The result in fahrenheit is:");
Console.WriteLine((celsiusDegrees * (9/5)) + 32);

```

אבל אם ננסה להריץ את הקוד עבור מספר כלשהו, נראה שמתקבלת תוצאה אחרת. 
למשל 100 מעלות צלסיוס הן 212 מעלות פרנהייט, אבל הקוד יתן לנו את התוצאה 132. 

כדי להבין למה, נדפיס את תוצאת החישוב צעד אחר צעד:

```csharp
Console.WriteLine("Please type the temprature in Celsius:");

int celsiusDegrees;
celsiusDegrees = int.Parse(Console.ReadLine());

Console.WriteLine("Step 1:");
Console.WriteLine(9 / 5);

Console.WriteLine("Step 2:");
Console.WriteLine(celsiusDegrees * (9 / 5));

Console.WriteLine("The result in fahrenheit is:");
Console.WriteLine((celsiusDegrees * (9/5)) + 32);
```

אם נריץ את הקוד הפעם, נגלה שהבעיה מתרחשת כבר בצעד הראשון, התוצאה של 9/5 היא 1, ולא השבר  $\frac{9}{5}$. וזאת מפני שכאשר סי שארפ מבצאת פעולות אריתמטיות (פעולות חשבון) היא יכולה לבצע אותן במספרים שלמים או בשברים. אבל בגלל שגם 9 וגם 5 הם שלמים, סי שארפ תניח שנבצע את כל הפעולה בשלמים, ולכן התוצאה תהיה 9 חלקי 5 מעוגל למטה למספר שלם, זאת אומרת 1.

כדי לתקן את הבעיה, אנחנו צריכים "להכריח" את שפת סי שארפ לעבוד בשברים, דרך אחת לעשות זאת היא לציין נקודה עשרונית במספר, למשל(נסו בעצמכם):

```csharp
Console.WriteLine(9 / 5.0);
```

כעת התוצאה תהיה 1.8. 
אם נתקן את הקוד המקורי שלנו בצורה כזו, באורח פלא כל החישוב פתאום יהיה נכון. 


```csharp
Console.WriteLine("Please type the temprature in Celsius:");

int celsiusDegrees;
celsiusDegrees = int.Parse(Console.ReadLine());

Console.WriteLine("The result in fahrenheit is:");
Console.WriteLine((celsiusDegrees * (9/5.0)) + 32);

```

מדוע זה קורה?  בואו נבין איך עובדות המרות (conversions) בשפת סי שארפ

## משתנה מסוג שבר - float / double

עד עכשיו הכרנו את **int** – מספר שלם, ללא חלק עשרוני.  
אבל לעיתים קרובות נצטרך לעבוד עם שברים, למשל 1.8, 3.14 או 0.5.  

לשם כך קיימים ב־C# טיפוסים מיוחדים:

- **float** – מספר עשרוני עם דיוק מוגבל (בערך 7 ספרות משמעותיות).
- **double** – מספר עשרוני עם דיוק גבוה יותר (בערך 15–16 ספרות משמעותיות).

בפועל, אנחנו נשתמש תמיד ב־**double**.  
הסיבה היא שזו הדרישה הרשמית של **משרד החינוך** לתוכנית הלימודים.  

חשוב לדעת: רוב מה שנאמר על **double** נכון גם ל־**float**.  
שניהם משמשים לייצוג מספרים עם חלק עשרוני, וההבדל העיקרי הוא ברמת הדיוק ובטווח המספרים שכל אחד מהם יכול לשמור.  

דוגמאות:

```csharp
double a = 3.14;   // double
float b = 3.14f;   // float (חייבים להוסיף f בסוף)
```


## איך סי שארפ "מרחיבה" את הביטוי לשברים

כאשר ביטוי מתמטי מכיל גם מספרים שלמים (**int**) וגם מספרים שבריים (**float** או **double**), שפת C# בוחרת *להרחיב* (enhance) את הביטוי כך שכל הפעולה תתבצע במספרים שבריים.  
כלומר, אם אפילו אחד מהאיברים בביטוי הוא `double` או `float`, שאר האיברים מומר אוטומטית לאותו סוג כדי למנוע איבוד דיוק.

לדוגמה:

```csharp
Console.WriteLine(9 / 5.0);
```

ההמרה מהסוג הזה נקראת המרה מרומזת (Implicit Conversion)

## המרה מרומזת (Implicit Conversion)

בשפת C# יש מקרים שבהם המהדר מבצע **המרה אוטומטית** בין טיפוסי נתונים שונים, בלי שנצטרך לכתוב זאת במפורש.  
זה נקרא **המרה מרומזת** (Implicit Conversion).

### מתי זה קורה?
המהדר מבצע המרה מרומזת כאשר:
- **אין סיכוי לאבד מידע**.  
  למשל, כל מספר שלם (**int**) יכול להפוך ל־**double** בלי בעיה, כי double יודע לייצג את כל הערכים של int (ועוד הרבה מעבר).
- **התוצאה בטוחה לשימוש** מבחינת טווח ודיוק.

### דוגמאות:
```csharp
int a = 5;
double b = a;   // המרה מרומזת – int → double
```

## המרה מפורשת (Explicit Conversion)

בניגוד להמרה מרומזת, יש מקרים שבהם שפת C# **לא** תבצע המרה אוטומטית, מפני שעלול להיות אובדן מידע.  
במצב כזה אנחנו צריכים לכתוב בעצמנו המרה מפורשת – **Casting**.

### איך עושים את זה?
אנחנו מוסיפים לפני הערך את הטיפוס שאליו נרצה להמיר, בתוך סוגריים עגולים:

```csharp
double a = 9.8;
int b = (int)a;   // המרה מפורשת – double → int
Console.WriteLine(b);   // התוצאה: 9
```

# תרגיל בית 

עברו על הטבלה המצורפת, מלאו בכל עמודה מה לדעתכם צריכה להיות התוצאה ואז הריצו את הקוד ובדקו מה התוצאה באמת. אם יש הבדל, נסו להבין למה קיבלתם תוצאה אחרת ממה שחשבתם.


דדליין: עד יום הראשון ה28 לספטמבר
אופן ההגשה: להדפיס את המסמך ולשלוח לי צילום או להמיר לוורד ולשלוח לי מסמך שבוא מילאתם את שתי העמודות

[לינק לקובץ התרגול](./practice.html.pdf)



