# פתרון מבחן מחצית - ינואר 2026

לינק למבחן - [mid_exam_10th_grade_2026.pdf](mid_exam_10th_grade_2026.pdf)

## שאלה 1 

#### סעיף a - טבלת מעקב
פרמטרים:

- n = 13132
- d = 3

| # | n | d | result | n > 0 | tmp | tmp == d |
|---|---|---|--------|-------|-----|----------|
| 6 | 13132 | 3 | _      | _     | _   | _        |
| 8 | _ | _ | 0      | _     | _   | _        |
| 10 | _ | _ | _      | true     | _   | _        |
| 12 | _ | _ | _      | _     | 2  | _        |
| 13 | _ | _ | _      | _     | _   | false        |
| 17 | 1313 | _ | _      | _     | _   | _        |
| 10 | _ | _ | _      | true     | _   | _        |
| 12 | _ | _ | _      | _     | 3   | _        |
| 13 | _ | _ | _      | _     | _   | true        |
| 15 | _ | _ | 1      | _     | _   | _        |
| 17 | 131 | _ | _      | _     | _   | _        |
| 10 | _ | _ | _      | true     | _   | _        |
| 12 | _ | _ | _      | _     | 1   | _        |
| 13 | _ | _ | _      | _     | _   | false        |
| 17 | 13 | _ | _      | _     | _   | _        |
| 10 | _ | _ | _      | true     | _   | _        |
| 12 | _ | _ | _      | _     | 3   | _        |
| 13 | _ | _ | _      | _     | _   | true        |
| 15 | _ | _ | 2      | _     | _   | _        |
| 17 | 1 | _ | _      | _     | _   | _        |
| 10 | _ | _ | _      | true     | _   | _        |
| 12 | _ | _ | _      | _     | 1   | _        |
| 13 | _ | _ | _      | _     | _   | false        |
| 17 | 0 | _ | _      | _     | _   | _        |
| 10 | _ | _ | _      | false     | _   | _        |

- תוצאה סופית: 2

#### סעיף b - תוצאות 
- CalcSomething(555, 5) -> 3
- CalcSomething(1, 2) -> 0
- CalcSomething(1517, 1) -> 2

#### סעיף c - הסבר

הפונקציה מקבלת מספר n וספרה d.
הפונקציה מחזירה כמה פעמים הספרה d מופיעה בתוך המספר n

## שאלה 2

### סעיף a - טבלאות מעקב

#### עבור CheckSomething(1)

| #  | i | found | i * i <= n | !found | i * i == n |
| -- | - | ----- | ---------- | ------ | ---------- |
| 3  | 1 | _     | _          | _      | _          |
| 4  | _ | false | _          | _      | _          |
| 5  | _ | _     | true       | true   | _          |
| 7  | _ | _     | _          | _      | true       |
| 9  | _ | true  | _          | _      | _          |
| 11 | 2 | _     | _          | _      | _          |
| 5  | _ | _     | false      | _      | _          |

תוצאה: true

#### עבור CheckSomething(2)

| #  | i | found | i * i <= n | !found | i * i == n |
| -- | - | ----- | ---------- | ------ | ---------- |
| 3  | 1 | _     | _          | _      | _          |
| 4  | _ | false | _          | _      | _          |
| 5  | _ | _     | true       | true   | _          |
| 7  | _ | _     | _          | _      | false      |
| 11 | 2 | _     | _          | _      | _          |
| 5  | _ | _     | false      | _      | _          |

תוצאה: false

#### עבור CheckSomething(4)

| #  | i | found | i * i <= n | !found | i * i == n |
| -- | - | ----- | ---------- | ------ | ---------- |
| 3  | 1 | _     | _          | _      | _          |
| 4  | _ | false | _          | _      | _          |
| 5  | _ | _     | true       | true   | _          |
| 7  | _ | _     | _          | _      | false      |
| 11 | 2 | _     | _          | _      | _          |
| 5  | _ | _     | true       | true   | _          |
| 7  | _ | _     | _          | _      | true       |
| 9  | _ | true  | _          | _      | _          |
| 11 | 3 | _     | _          | _      | _          |
| 5  | _ | _     | _          | false  | _          |

תוצאה: true

### סעיף b - הסבר

הפונקציה מקבלת מספר שלם n ומחזירה true אם יש לו שורש שלם, אחרת היא מחזירה false

### סעיף c - מימוש פונקציה 

```csharp
    int count = 0;
    int n = int.Parse(Console.ReadLine());

    while (n != 0)
    {
        if (CheckSomething(n))
        {
            count++;
        }

        n = int.Parse(Console.ReadLine());
    }

    Console.WriteLine(count);
```

## שאלה 3

### סעיף a IsRightTriangle

זוהי שאלה קלאסית לעצלנים, המימוש מאוד פשוט אבל דורש מעט מחשבה

דרך אחת לממש את הפונקציה היא לבדוק מי הצלע הגדולה ביותר (שלוש אפשרויות) ואז לבדוק את סכום הריבועים

```csharp
public static bool IsRightTriangle(int a, int b, int c)
{
    int hypotenuse; // ככה קוראים ליתר באנגלית
    int leg1;
    int leg2;

    if (a > b && a > c)
    {
        hypotenuse = a;
        leg1 = b;
        leg2 = c;
    }
    else if (b > a && b > c)
    {
        hypotenuse = b;
        leg1 = a;
        leg2 = c;
    }
    else
    {
        hypotenuse = c;
        leg1 = a;
        leg2 = b;
    }

    return hypotenuse * hypotenuse == leg1 * leg1 + leg2 * leg2;
}
```

במקרה הזה, אפשר לשקול גם להשתמש בreturn  באמצע פונקציה (חוקי לגמרי כמובן) ואז ניתן לכתוב באופן הבא:
```csharp
public static bool IsRightTriangle(int a, int b, int c)
{
   
    if (a > b && a > c)
    {
        return b*b + c*c == a*a;
    }
    else if (b > a && b > c)
    {
        return a*a + c*c == b*b;
    }
    else if (c > a && c > b)
    {
        return 
    }
    // אם הגענו לכאן סימן שאין צלע הכי גדולה (אין יתר) ולכן משולש זה לא

    return false;
}
```


אבל, אם אנחנו אנשים באמת עצלנים (יעילים אנרגטית) אז בעצם נזכור שעבור מספרים גדולים מ1 אין באמת צורך לבדוק מי הצלע הגדולה, ברגע שריבוע צלע כלשהיא הוא סכום ריבועי הצלעות, היא גם הכי גדולה, אין אפשרות אחרת. 
ולכן ניתן גם לכתוב פתרון מקוצר

```csharp
public static bool IsRightTriangle(int a, int b, int c)
{
    return (a*a == b*b + c*c) || (b*b == a*a + c*c) || (c*c == a*a + b*b);
}
```

כמו שאומר אנטולי (קופה ראשית) - "בובום ! תודה רבה, שבת שלום"

### סעיף b תכנית ראשית

החלק המעצבן הוא שהפונקציה הפנימית כבר זיהתה אם זה משולש, אבל בשביל לחשב את השטח עדיין נצטרך לזהות מי היתר (ומי הניצבים)

```csharp 
int a = int.Parse(Console.ReadLine());
int b = int.Parse(Console.ReadLine());
int c = int.Parse(Console.ReadLine());

if (IsRightTriangle(a, b, c))
{
    int hypotenuse;
    int leg1;
    int leg2;

    // זיהוי היתר והניצבים
    if (a > b && a > c)
    {
        leg1 = b;
        leg2 = c;
    }
    else if (b > a && b > c)
    {
        leg1 = a;
        leg2 = c;
    }
    else
    {
        leg1 = a;
        leg2 = b;
    }

    // חישוב שטח
    int area = (leg1 * leg2) / 2;
    Console.WriteLine(area);
}
else
{
    int perimeter = a + b + c;
    Console.WriteLine(perimeter);
}
```

זה הרעיון, כרגיל בשאלות מימוש, כל פתרון תקין שעומד בתנאים יתקבל. 

## שאלות אמריקאיות 4-16

### שאלה 4
**תשובה:** א. כן  
**הסבר:** `x > 5` הוא `true` כי 8 > 5. באופרטור OR (`||`) מספיק שתנאי אחד יהיה `true` כדי שכל הביטוי יהיה `true`.

### שאלה 5
**תשובה:** א. כן  
**הסבר:** התנאי `x > 3` מתקיים (5 גדול מ־3), ולכן גוף ה־`if` מתבצע והטקסט "A" יודפס למסך.

### שאלה 6
**תשובה:** א. 2  
**הסבר:** `x` הוא משתנה מטיפוס `int`, ולכן החלוקה היא חלוקה של מספרים שלמים. `12 / 5` שווה ל־2 (החלק השלם בלבד).

### שאלה 7
**תשובה:** א. true  
**הסבר:** 9 מתחלק ב־3 ללא שארית, ולכן `9 % 3` שווה ל־0 והביטוי `== 0` מחזיר `true`.

### שאלה 8
**תשובה:** ג. 5  
**הסבר:** הלולאה רצה כל עוד `i <= 4`. הערכים של `i` יהיו: 1 → 2 → 3 → 4 → 5. כשה־`i` שווה 5 התנאי נכשל והלולאה מסתיימת.

### שאלה 9
**תשובה:** ב. false  
**הסבר:** הביטוי `a > 3` הוא `false` כי 2 אינו גדול מ־3. באופרטור AND (`&&`) אם אחד התנאים `false` כל הביטוי `false`.

### שאלה 10
**תשובה:** א, ב, ד  
**הסבר:**
- `One` – חוקי (אותיות).
- `two` – חוקי (אותיות קטנות).
- `3three` – לא חוקי, שם משתנה לא יכול להתחיל במספר.
- `_four` – חוקי, מותר להתחיל בקו תחתון.

### שאלה 11
**תשובה:** א. כן  
**הסבר:** ערכי `i` יהיו: 0 → 2 → 4 → 6 → 8. גוף הלולאה מתבצע 4 פעמים בדיוק, ומאחר ונשאל האם הוא מתבצע 4 פעמים או יותר, התשובה היא כן.

**הערה** למרות האמור לעיל, הניסוח שבחרתי מבלבל (כפי שהבנתי במהלך המבחן) ולכן כל מי שענה יקבל את הניקוד על השאלה בלי קשר לתשובה שלו. 

### שאלה 12
**תשובה:** ג. 9  
**הסבר:** הלולאה רצה עבור `i = 2, 3, 4`. הסכום הוא `2 + 3 + 4 = 9`.

### שאלה 13
**תשובה:** ב. true  
**הסבר:** `6 + 1` שווה ל־7. הפונקציה בודקת אם המספר אי־זוגי, ו־`7 % 2` שווה ל־1, לכן מוחזר `true`.

### שאלה 14
**תשובה:** ב. 1.5  
**הסבר:** `a` הוא `double` ולכן החלוקה מתבצעת כחלוקה עשרונית. `3 / 2` שווה ל־1.5.

### שאלה 15
**תשובה:** ב. 11  
**הסבר:** `"1"` הוא מחרוזת, ולכן האופרטור `+` מבצע חיבור מחרוזות. התוצאה היא `"11"`.

### שאלה 16
**תשובה:** א. כן  
**הסבר:** `x > 2` הוא `false`, אך `IsPositive(y)` מחזיר `true` כי `5 > 0`. באופרטור OR מספיק תנאי אחד `true` ולכן הביטוי כולו `true`.


## שאלת בונוס

אוקי, זו בהחלט היתה שאלה מתחכמת ומי שענה נכון הרוויח את הנקודות בכבוד (ומי שלא, לא נורא, זה לא משהו שהייתם אמורים להכיר)

קודם כל תשובה: הפונקציה הנתונה מחשבת "עצרת", עצרת במתמטיקה למי שלא מכיר הוא מכפלה של כל המספרים השלמים עד מספר מסויים, למשל עצרת של 6 היא

6! = 1X2X3X4X5X6 = 720

אבל הקטע הטריקי כאן הוא איך הפונקציה עובדת, במקום לעשות לולאת for כמו פונקציה מתורבתת, הדרך שהפונקציה הזו פועלת נקראת "רקורסיה" ונלמד עליה עוד הרבה בהמשך. ברקורסיה, אנחנו לוקחים בעיה ואז מפרקים אותה לבעיה יותר קטנה. 
ואז הפונקציה קוראת לעצמה שוב ושוב עם הבעיה הקטנה יותר (ואז גם הפונקציה הנקראת קוראת לעצמה עוד פעם ועוד פעם)
עד נקודה מסויימת שנקראת תנאי עצירה, במקרה שלנו זה המקרה של n=1

יהיה הכי קל להבין זאת עם דוגמא:

עבור 1 הפונקציה מחזירה 1, קל ופשוט

עבור 2 הפונקציה מחזירה

```n * CalcThis(n-1)```

אבל n-1 הוא 1. אז בעצם אפשר להגיד שהפונקציה מחזירה

```n * CalcThis(1)```

ואת הפתרון של 1 אנחנו כבר יודעים, הוא 1, לכן בעצם הפונקציה מחזירה

```n * 1```

כלומר 2

עבור 3 הפונקציה גם מחזירה

```n * CalcThis(n-1)```

אבל שוב, את החלק של `CalcThis(2)` אנחנו כבר יודעים, הוא נותן 2

ולכן התוצאה היא

```n * 2```

כלומר 6

ובצורה כזו נמשיך לחשב ונגיע לכך שהנוסחא היא 

```CalcThis(6)``` =>
```6*CalcThis(5)``` =>
```6*5*CalcThis(4)``` =>
```6*5*4*CalcThis(3)``` =>
```6*5*4*3*CalcThis(2)``` =>
```6*5*4*3*2*CalcThis(1)``` =>
```6*5*4*3*2*1```

